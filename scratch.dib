#!fsharp

open System
open System.IO

let day01input = File.ReadAllLines("day01input.txt")
let day02input = File.ReadAllLines("day02input.txt")
let day03input = File.ReadAllLines("day03input.txt")

let flip fn x y = fn y x

module String =
    let toCharArray (x: string) = x.ToCharArray()

#!fsharp

type Food = { calories: int }
module Food =
    let (+) f1 f2 = { calories = f1.calories + f2.calories }
    let create c = { calories = c }
    let calories f = f.calories

type PlayerMove =
    | Rock
    | Paper
    | Scissors
module PlayerMove =
    let parse =
        function
        | "A" | "X" -> Rock
        | "B" | "Y" -> Paper
        | "C" | "Z" -> Scissors
        | _ -> raise <| Exception("Unrecognised move")

    let score =
        function
        | Rock -> 1
        | Paper -> 2
        | Scissors -> 3

type RoundResult =
    | Lose
    | Win
    | Draw
module RoundResult =
    let parse =
        function
        | "X" -> Lose
        | "Y" -> Draw
        | "Z" -> Win
        | _ -> raise <| Exception("Unrecognised move")

    let score =
        function
        | Lose -> 0
        | Win -> 6
        | Draw -> 3

type Round = PlayerMove * PlayerMove
module Round =
    let outcome =
        function
        | (p1m, p2m) when p1m = p2m -> Draw
        | (Rock, playerMove) when playerMove <> Paper -> Lose
        | (Paper, playerMove) when playerMove <> Scissors -> Lose
        | (Scissors, playerMove) when playerMove <> Rock -> Lose
        | _ -> Win

type RoundStrategy = PlayerMove * RoundResult
module RoundStrategy =
    let response =
        function
        | (Rock, Win) -> Paper
        | (Rock, Lose) -> Scissors
        | (Paper, Win) -> Scissors
        | (Paper, Lose) -> Rock
        | (Scissors, Win) -> Rock
        | (Scissors, Lose) -> Paper
        | (m, Draw) -> m

type Item = Item of char
module Item =
    let priority (Item x) =
        if (Char.IsLower(x)) then
            (int x) - (int 'a') + 1
        else
            (int x) - (int 'A') + 27

type Items = Item[]
module Items =
    let empty = Array.empty
    let parse = Array.map Item
    
    let itemsInAll (is: Items seq) =
        is
        |> Seq.map Set.ofArray
        |> Set.intersectMany

type Rucksack =
    {
        compartments: Items * Items
    }

module Rucksack =
    let empty = { compartments = Compartment.empty, Compartment.empty }
    let parse (x: string) =
        String.toCharArray x
        |> Items.parse
        |> Array.splitInto 2
        |> (fun y -> {compartments = y[0], y[1]})

    let itemInBothCompartments ({ compartments = c1, c2 }) =
        let matches = Items.itemsInAll [c1; c2]

        if matches <> Set.empty then
            matches |> Set.toList |> List.head |> Some
        else
            None

    let priority c =
        itemInBothCompartments c
        |> function
            | Some i -> Item.priority i
            | None -> 0

    let items ({ compartments = c1, c2 }) =
        Array.concat [c1; c2]

type Elf =
    { food: Food list
      rucksack: Rucksack }

module Elf =
    let empty = { food = []; rucksack = Rucksack.empty }
    let food e = e.food
    let totalFood = food >> (List.reduce Food.(+))

type ElfGroup =
    { elfs: Elf * Elf * Elf }

module ElfGroup =
    let create elfs =
        match elfs with
        | [| x; y; z|] -> {elfs = x, y, z}
        | _ -> raise <| Exception("Elfs not divisible into groups of 3")

    let badge { elfs = e1, e2, e3 } =
        [| e1; e2; e3 |]
        |> Seq.map (fun e -> e.rucksack)
        |> Seq.map Rucksack.items
        |> Items.itemsInAll
        |> Set.toList
        |> List.head

#!fsharp

let elfs =
    day01input
    |> Seq.map (
        function
        | "" -> None
        | num -> int num |> Food.create |> Some)
    |> Seq.fold (fun elfs foodOption ->
        match foodOption with
        | None -> (Elf.empty) :: elfs
        | Some f -> 
            let currentElf = List.head elfs
            let otherElfs = List.tail elfs
            { currentElf with food = (f :: currentElf.food)} :: otherElfs)
        [ Elf.empty ]

let mostCalories =
    elfs
    |> Seq.map Elf.totalFood
    |> Seq.maxBy Food.calories

let foodCarriedByTop3 =
    elfs
    |> Seq.map Elf.totalFood
    |> Seq.sortByDescending Food.calories
    |> Seq.take 3
    |> Seq.sumBy Food.calories

let rounds =
    day02input
    |> Seq.map (fun x -> PlayerMove.parse (x.Substring(0,1)), PlayerMove.parse (x.Substring(2,1)))
    |> Seq.map (fun (p1m, p2m) -> p1m, p2m, Round.outcome (p1m, p2m))

let score =
    rounds
    |> Seq.map (fun (p1m, p2m, outcome) ->
        PlayerMove.score p2m + RoundResult.score outcome)
    |> Seq.sum

let roundStrategys =
    day02input
    |> Seq.map (fun x -> PlayerMove.parse (x.Substring(0,1)), RoundResult.parse (x.Substring(2,1)))

let moves =
    roundStrategys
    |> Seq.map RoundStrategy.response

let score2 =
    roundStrategys
    |> Seq.map snd
    |> Seq.zip moves
    |> Seq.map (fun (move, outcome) -> PlayerMove.score move + RoundResult.score outcome)
    |> Seq.sum

let rucksacks =
    day03input
    |> Seq.map Rucksack.parse

let groupedElfs =
    rucksacks
    |> Seq.map (fun r -> { food = []; rucksack = r})
    |> Seq.chunkBySize 3
    |> Seq.map ElfGroup.create

let priorityTotal =
    groupedElfs
    |> Seq.map ElfGroup.badge
    |> Seq.map Item.priority
    |> Seq.sum
